## Sarah Wiessler - Homework 5

**Design**
1. Setting the time aside to evaluate the best way to approach and implement our ideas (i.e. design methods) 
let the group thoroughly critique the ideas that we had in the first place. We realized that some of the ideas we had in the 
first place did not make sense in an agile environment, as well as the environment we would be building the application on. Taking
into consideration which methods would specifically help us reach our goals also dramatically helped set up a roadmap for the project,
and the time table for the specific features we wanted to complete.
2. It was very difficult to stick to those design methods. We struggled to balance a consistent workflow amongst our other classwork.
We would rush to finish each iteration, and even though we set clear plans for work, life easily got in the way. During the pivots the
team had to implement, the clear plan we had set in place wasn't as clear anymore, and the original intention for our design methods
got lost in the rush. Next time, for each pivot that team made, I would make a new design plan. Due to time constraints it would just 
be more of an update, but continue to thoroughly evaluate each decision we were making and how it would effect the project as a whole.
I would also create a shared digital calendar with each work day goal so that we do not have to rely on a hard copy to keep track what 
we need to do each day.
3. The architectural design component was very helpful in laying out how the code we should write should interact with other elements
of the project. Additionally, thoroughout the semester we have used use case and sequence diagrams. Each time they have proved to be a 
quick and easy way to establish and visualize some main functions of the project being created. I will definitely be continuing to use
those methods of design for many future projects. 

**Implementation**
1. The most helpful part of that continuous integration practice was the encouraging bits when at least one part of the bot would work.
In order to keep morale high and encouragement that the team is pursuing the correct path, getting individual elements to work often is
essential. It is also helpful to switch between different tasks so that your brain does not get too bored during implementation. The changing
of the tasks helps the brain stay alert and constantly looking for new ways to examine problems and fix any potential issues. Lastly, it ensures
that building upon the old integration won't cause major problems for future development. This is important so that the team does not waste time in 
the future fixing old problems as well as discovering that new integration simply won't work with old broken framework. 
2. The most difficult part was being able to be testing and integrating towards a common goal. Sometimes the overlap of ideas and task implementation
forced team members to abandon code that was written because it didn't work with the new implementation. Also, the cycle of implementation and testing 
would get messed up by the third party applications shortcomings due to an updated API. The materials we would use to guide us led us down some roads that 
proved to be difficult to manage during the implementation phases. Sometimes team members would work using different parts of the API which ended up conflicting
and actually deactivating our bot in one instance. 
3. I would continue to use the agile cycle, I truly believe it is the most thorough and effective way to approach software development. I think the small iterations
is key to success. I would absolutely use this method again, but ensure that the tasks were clear and the sprints were calculated. I believe that if we had a concrete 
work schedule it might have been easier. 

**Process**
1. The level and iterations of our project were completed in a team like manner, many times with close communication during the committing and pushing process, so we did 
not require the resources for code review. However, the kanban board proved to be very helpful over the course of this project. I had only once been exposed to the kanban board
on a project I did not add significant contributions for, so I never got the full experience of creating and closing issues. This was a very easy way to stay organized as a team, 
and the clear user interface made it very easy to tell what tasks could be picked up and what was already being handled. 
2. The use of user stories as a kanban board is a wonderful idea, but did not fit our small scale project. We tried to adapt 
the user stories so that each issue created reflected them, however they seemed to get muddled between tasks and stories. Also, the tasks could overlap and get confused, 
and sometimes team members would start working on tasks that were closely related with the other tasks that they were completing so it made sense, however it was not reflected on the board. 
This created some confusion in task distribution. It was eventually resolved, but was time wasted on throwaway code and discussion.
3. I would love to continue honing my agile development skills. I believe strictly implementing the weekly cycle, since it tended to stray during our project. 
I also believe daily scrums are a great thing in the workplace, but for a school project our scrum about every three days worked really well. The code was not complicated nor were we removed enough from multiple iterations to need code review for this project. However, I am very grateful to 
have learned the skill and the resources out there in order to help with it. Additionally, I would absolutely use the kanban board again whether it was in the Trello format or on the github interface. 
I also noticed that the github interface had many different formatting options for the board itself, so it could be customized in the future to accomodate for different project types. 

**Overall**

While the team mostly operated in a modified agile development environment, there are influences from many traditional software models. Such as, when starting out we believed the requirements of the project would not change, because we 
were only responsible for ourselves. We planned for a very specific environment with a lot of up front requirements and meticulous architecture design. We were not prepared for the absolute walls we would hit during implementation due to 
the constraints of our knowledge and the availability of resources through third party websites. At one point when our requirements were going through a period of change, 
we almost adapted the incremental model, because we realized the platforms that we needed to work off of were rapidly changing. We pivoted our whole project from a bot made with our own server to hosting a bot through slack. This completely changed
the requirements for architecture so we needed to redesign. Then we needed to implement. This did not necessarily follow the agile framework as closely as we had planned to because there was no real implementation and testing before the requirements changed.
The incremental model works well for a project that has constantly changing requirements, and might be helpful to integrate into the agile method if you are working for a fickle customer, or do not have a lot of experience with the technology you are implementing. 
You can use agile granularity alongside more traditional software development models in order to help organize the specific tasks that need to be completed. The epics can be substituted for stories where the product needs a "get it done right the first time" mentality. 
These epics can be related by a theme to make sure that everyone is continuing to work on the same page. Although software development practices have evolved over the years, they continue to derive from eachother and all share the same purpose of completing a product. 


